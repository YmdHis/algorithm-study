### 冒泡排序
比较相邻的两个元素，如果第一个比第二个大，就交换位置；
对所有相邻的一对做同样的工作，从头到尾，这样最后一个应该是最大的数；
重复上面的步骤，除了最后一个。

**改进冒泡排序**
* 设置一个标志位 ***i***，记录最后一次有交换操作的位置。这样这个位置之后的顺序肯定是已经正确排序了的，下一次轮的排序就只需要到这个标志位。
* 冒泡排序的时间复杂度是从**n -> n^2**。所以设置一个标记记录本次是否进行了交换，如果本轮排序，一次交换都没有产生，说明数组已经是按顺序排列了。

**算法分析**
* 时间复杂度 O(n^2)。最好情况O(n)， 最坏情况O(n^2)
* 空间复杂度 O(1)